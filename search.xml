<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Webpack打包处理IE低版本(IE8及以下)浏览器兼容问题</title>
      <link href="/2019/09/25/webpack-ie/"/>
      <url>/2019/09/25/webpack-ie/</url>
      
        <content type="html"><![CDATA[<p><a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a> 是一个前端资源加载/打包工具，现在版本已经 release 到 v2.6.1，今天的文章不直接介绍Webpack的API及使用，而是对最近项目开发中使用Webpack打包时处理IE低版本(IE8及以下)浏览器兼容问题做一次总结。</p><p>PC端项目前端基础技术选型jQuery + ES6 + EJS + Babel + Webpack：</p><ul><li>jQuery：提供选择器和ajax接口兼容支持；</li><li>ES6：跟进前端趋势，方便向后兼容；</li><li>EJS：提供前端模板引擎支持；</li><li>Babel：提供 ES6 转码支持；</li><li>Webpack: 提高前端资源加载/打包；</li></ul><p>项目开发过程都在 Chrome 浏览器中，一切都OK，没有任何问题，当在IE9以下浏览器中调试发现好多坑，现总结如下，以后新手参考。</p><h2 id="Case-One-default-、-class、catch-ES3中保留字问题"><a href="#Case-One-default-、-class、catch-ES3中保留字问题" class="headerlink" title="Case One: default 、 class、catch ES3中保留字问题"></a>Case One: <code>default</code> 、 <code>class</code>、<code>catch</code> ES3中保留字问题</h2><p>报错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT1048: 缺少标识符</span><br></pre></td></tr></table></figure><p>对应代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">e.n = function (t) &#123;</span><br><span class="line">    var n = t &amp;&amp; t.__esModule ? function () &#123;</span><br><span class="line">        return t.default</span><br><span class="line">    &#125; : function () &#123;</span><br><span class="line">        return t</span><br><span class="line">    &#125;;</span><br><span class="line">    return e.d(n, &quot;a&quot;, n), n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上查找资料，webpack有一款loader插件<a href="https://www.npmjs.com/package/es3ify-loader" target="_blank" rel="noopener">es3ify-loader</a>来处理ES3的兼容问题，修改webpack配置，问题解决，添加规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">            test: /.js$/,</span><br><span class="line">            enforce: &apos;post&apos;, // post-loader处理</span><br><span class="line">            loader: &apos;es3ify-loader&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个loader是干啥用的捏，就是把这些保留字给你加上引号，使用字符串的形式引用，请看实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 编译前</span><br><span class="line">function(t) &#123; return t.default; &#125;</span><br><span class="line"></span><br><span class="line">// 编译后</span><br><span class="line">function(t) &#123; return t[&quot;default&quot;]; &#125;</span><br></pre></td></tr></table></figure><h2 id="Case-Two-uglify-js产生问题"><a href="#Case-Two-uglify-js产生问题" class="headerlink" title="Case Two: uglify-js产生问题"></a>Case Two: uglify-js产生问题</h2><p>重新构建，在IE低版本浏览器预览，使用 <code>webpack.optimize.UglifyJsPlugin</code> 压缩时，又报上面同样的错误了，重新采用 beauty:true, build 发现引号被压缩掉了，究其原因，研究了下uglify-js默认配置，发现了 <code>compress.properties</code> 属性，增加build options如下，问题解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">    compress: &#123;</span><br><span class="line">        properties: false,</span><br><span class="line">        warnings: false</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        beautify: true</span><br><span class="line">    &#125;,</span><br><span class="line">    sourceMap: false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Case-Three-uglify-js问题"><a href="#Case-Three-uglify-js问题" class="headerlink" title="Case Three: uglify-js问题"></a>Case Three: uglify-js问题</h2><p>重新构建，在IE低版本浏览器预览，使用 <code>webpack.optimize.UglifyJsPlugin</code> 压缩时，又报上面同样的错误了，报错代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    catch: function (t) &#123;</span><br><span class="line">        return this.then(null, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续查找uglify-js配置，发现 <code>output.quote_keys</code>，修改build options，问题解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">    compress: &#123;</span><br><span class="line">        properties: false,</span><br><span class="line">        warnings: false</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        beautify: true,</span><br><span class="line">        quote_keys: true</span><br><span class="line">    &#125;,</span><br><span class="line">    sourceMap: false</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;catch&quot;: function(t) &#123;</span><br><span class="line">        return this.then(null, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Case-Four-uglify-js问题"><a href="#Case-Four-uglify-js问题" class="headerlink" title="Case Four: uglify-js问题"></a>Case Four: uglify-js问题</h2><p>重新构建，在IE低版本浏览器预览，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT3126: 无法设置未定义或 null 引用的属性</span><br></pre></td></tr></table></figure><p>继续分析压缩后代码，发现还是uglify-js问题，其mangle 配置属性 <code>mangle.screw_ie8</code> 默认为 true， 什么意思捏，意思就是把支持IE8的代码clear掉，screw you =&gt; 去你的，修改压缩配置项，重新编译，问题解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">    compress: &#123;</span><br><span class="line">        properties: false,</span><br><span class="line">        warnings: false</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        beautify: true,</span><br><span class="line">        quote_keys: true</span><br><span class="line">    &#125;,</span><br><span class="line">    mangle: &#123;</span><br><span class="line">        screw_ie8: false</span><br><span class="line">    &#125;,</span><br><span class="line">    sourceMap: false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Case-Five-ES5的API兼容报错"><a href="#Case-Five-ES5的API兼容报错" class="headerlink" title="Case Five: ES5的API兼容报错"></a>Case Five: ES5的API兼容报错</h2><p>在 webpack 的 entry 入口文件top引入 <code>es5-shim</code> 问题解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;es5-shim&apos;);</span><br><span class="line">require(&apos;es5-shim/es5-sham&apos;);</span><br></pre></td></tr></table></figure><h2 id="Case-Six-Console-log-问题"><a href="#Case-Six-Console-log-问题" class="headerlink" title="Case Six: Console.log 问题"></a>Case Six: Console.log 问题</h2><p>在 webpack 的 entry 入口文件top引入 <code>console-polyfill</code> 问题解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;console-polyfill&apos;);</span><br></pre></td></tr></table></figure><h2 id="Case-Seven-Promise-兼容"><a href="#Case-Seven-Promise-兼容" class="headerlink" title="Case Seven: Promise 兼容"></a>Case Seven: Promise 兼容</h2><p>在 webpack 的 entry 入口文件top引入 <code>es6-promise</code> 问题解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;es6-promise&apos;);</span><br></pre></td></tr></table></figure><h2 id="Case-Eight-Object-defineProperty-问题"><a href="#Case-Eight-Object-defineProperty-问题" class="headerlink" title="Case Eight: Object.defineProperty 问题"></a>Case Eight: Object.defineProperty 问题</h2><p>这个case 应该说是最难搞的一个case了，耗时也比较长，关键点在于使用 <code>es5-shim</code>/<code>es5-sham</code>也有问题，查看你官网发现在低版本浏览器也会有问题，官网描述如下：</p><blockquote><p>⚠️ Object.defineProperty<br>In the worst of circumstances, IE 8 provides a version of this method that only works on DOM objects. This sham will not be installed. The given version of defineProperty will throw an exception if used on non-DOM objects.<br>In slightly better circumstances, this method will silently fail to set “writable”, “enumerable”, and “configurable” properties.<br>Providing a getter or setter with “get” or “set” on a descriptor will silently fail on engines that lack “defineGetter” and “defineSetter”, which include all versions of IE.<br><a href="https://github.com/es-shims/es5-shim/issues#issue/5" target="_blank" rel="noopener">https://github.com/es-shims/es5-shim/issues#issue/5</a></p></blockquote><p>那这个Object.defineProperty 是如何产生的呢，这个是babel编译后产生的，当我们在代码使用 <code>import``export</code> ES6 Module时出现的，那你可能最直接的想法就是我不用ES6 Module了，改用Commonjs规范，OK，修改后编译，确实解决了问题，但是查看代码里还是有一段代码的，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">e.d = function(t, n, r) &#123;</span><br><span class="line">    e.o(t, n) || Object.defineProperty(t, n, &#123;</span><br><span class="line">        &quot;configurable&quot;: !1,</span><br><span class="line">        &quot;enumerable&quot;: !0,</span><br><span class="line">        &quot;get&quot;: r</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, e.n = function(t) &#123;</span><br><span class="line">    var n = t &amp;&amp; t.__esModule ? function() &#123;</span><br><span class="line">        return t[&quot;default&quot;];</span><br><span class="line">    &#125; : function() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;;</span><br><span class="line">    return e.d(n, &quot;a&quot;, n), n;</span><br><span class="line">&#125;, e.o = function(t, e) &#123;</span><br><span class="line">    return Object.prototype.hasOwnProperty.call(t, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码已经做了容错判断。</p><h2 id="Case-Nine-Object-defineProperty-问题"><a href="#Case-Nine-Object-defineProperty-问题" class="headerlink" title="Case Nine: Object.defineProperty 问题"></a>Case Nine: Object.defineProperty 问题</h2><p>重新构建，加入 <code>json3</code> 处理 JSON 对象兼容时，代码在此处抛出了异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var hasGetter = &apos;get&apos; in descriptor;</span><br><span class="line">var hasSetter = &apos;set&apos; in descriptor;</span><br><span class="line">if (!supportsAccessors &amp;&amp; (hasGetter || hasSetter)) &#123;</span><br><span class="line">    throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析supportsAccessors代码逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var supportsAccessors = owns(prototypeOfObject, &apos;__defineGetter__&apos;);</span><br></pre></td></tr></table></figure><p>通过断点调试，supportsAccessors值为false且hasGetter或者hasSetter时抛出了异常，也就是说当前js引擎不支持访问器属性，却在属性描述符中设置了get，set,那么就会抛出异常。查看 <a href="https://github.com/zuojj/fedlab/issues/“defineGetter”的兼容情况是只兼容IE11" target="_blank" rel="noopener">defineGetter</a> 的兼容情况，只兼容IE11，虽然IE9、IE10同样不支持defineGetter,不过他们直接支持Object.defineProperty方法和get语法，无需sham，所以代码并不会走到异常这里。但是IE8以下就扯淡了。解决这种情况只能修改源代码了。</p><p>至此，Webpack打包时，IE低版本浏览器(IE8及以下)遇到的兼容问题就总结这里，如果你有新的问题，欢迎留言。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决ie低版本浏览器兼容rgba属性</title>
      <link href="/2019/09/25/ie-rgba/"/>
      <url>/2019/09/25/ie-rgba/</url>
      
        <content type="html"><![CDATA[<p>在使用rgba设置元素颜色属性时，ie低版本存在兼容性问题。</p><p>html代码如下<br><code>&lt;div class=&quot;test&quot;&gt;&lt;img src=&quot;img/1.png&quot;&gt;&lt;i&gt;覆盖文字&lt;/i&gt;&lt;/div&gt;</code></p><p>CSS代码如下<br><img src="https://user-images.githubusercontent.com/13929056/58398942-17d1a180-8089-11e9-92e2-85396132f6b2.png" alt="image"><br>IE10，IE8,IE7均显示正常，<br><img src="https://user-images.githubusercontent.com/13929056/58398954-24ee9080-8089-11e9-9b53-94fdbdb1055e.png" alt="image"><br><img src="https://user-images.githubusercontent.com/13929056/58398959-2750ea80-8089-11e9-862c-0d45619800e9.png" alt="image"><br>但在IE9下却出现问题：<br><img src="https://user-images.githubusercontent.com/13929056/58398975-2d46cb80-8089-11e9-823a-5cbcca93d36d.png" alt="image"><br>问题所在：<br>ie9下会重复应用filter和rgba导致透明度失效<br><strong>解决方法：</strong><br>方法1：<br>取消ie9下的滤镜css：</p><p><strong>:root .test i{filter:none;}</strong> </p><p>取消ie9下的滤镜css：</p><p>:root .test i{filter:none;} </p><p>这里用到了CSS3 :root 选择器：所有主流浏览器均支持 :root 选择器，除了 IE8 及更早的版本，而滤镜filter只有ie9以及更低的ie版本才支持，ie10开始已废弃不支持filter，这样刚好可利用:root来实现针对ie9的hack!!<br>装了ie10或更高版本的ie，可用ietester新建ie9模式标签查看上面代码运行效果。<br>(注意：装了ie10或更高版本的ie，即使将文档模式调成ie9，会发现上面 的代码也显示正确，合理的解释是：ie10开始已废弃不支持filter，即使文档模式调成ie9，filter也不会生效！另外提一下 css \9 写法是针对ie所有版本的hack写法，网上说的只是针对ie6~8的hack说法是错误的！)<br>全兼容完整代码如下：<br><code>.test i{         background:rgba(0,0,0,.8);         filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#b2000000, endColorstr=#b2000000);}:root .test i{filter:none;}</code></p><p>输入十六进制的颜色值以及透明度，自动在IE的过渡滤镜以及CSS3中的rgba属性之间进行十六进制与十进制的换算。在线转换工具<br><a href="http://linxz.github.io/tianyizone/hex_color.html" target="_blank" rel="noopener">http://linxz.github.io/tianyizone/hex_color.html</a><br>`</p><h2 id="输入十六进制的颜色值以及透明度，自动在IE的过渡滤镜以及CSS3中的rgba属性之间进行十六进制与十进制的换算。在线转换工具http-linxz-github-io-tianyizone-hex-color-html"><a href="#输入十六进制的颜色值以及透明度，自动在IE的过渡滤镜以及CSS3中的rgba属性之间进行十六进制与十进制的换算。在线转换工具http-linxz-github-io-tianyizone-hex-color-html" class="headerlink" title="输入十六进制的颜色值以及透明度，自动在IE的过渡滤镜以及CSS3中的rgba属性之间进行十六进制与十进制的换算。在线转换工具http://linxz.github.io/tianyizone/hex_color.html"></a>输入十六进制的颜色值以及透明度，自动在IE的过渡滤镜以及CSS3中的rgba属性之间进行十六进制与十进制的换算。在线转换工具<a href="http://linxz.github.io/tianyizone/hex_color.html" target="_blank" rel="noopener">http://linxz.github.io/tianyizone/hex_color.html</a></h2><p>`</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解浏览器缓存，教你提高用户体验</title>
      <link href="/2019/09/25/brower-cache/"/>
      <url>/2019/09/25/brower-cache/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-区分Expires和Cache-Control"><a href="#1-1-区分Expires和Cache-Control" class="headerlink" title="1.1 区分Expires和Cache-Control"></a>1.1 区分Expires和Cache-Control</h3><p>以一个接口返回的响应头为例：<br><img src="https://user-images.githubusercontent.com/13929056/58398559-02a84300-8088-11e9-9b00-45fed12a8353.png" alt="image"><br>这里我画了张思维导图，对Expires和Cache-Control做比较：<br><img src="https://user-images.githubusercontent.com/13929056/58398566-089e2400-8088-11e9-9308-6252caff9978.png" alt="image"><br>具体介绍Expires和Cache-Control：</p><p>Expires:</p><p>(1)Expires是HTTP1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略；</p><p>(2)Expires规定了缓存失效时间（Date为当前时间），是绝对时间。由于Expires返回的是一个绝对时间，在服务器时间与客户端时间相差较大的时候，缓存命中不准确；</p><p>Cache-Control：</p><p>(1)Cache-Control是HTTP1.1的</p><p>(2)Cache-Control的max-age规定了缓存有效时间（2552s)，是相对时间；</p><p>(3)若响应头Expires和Cache-Control同时存在，Cache-Control优先级高于Expires</p><p>Cache-Control的常用指令：</p><p>no-cache：不使用本地缓存，需要使用协商缓存，也就是先与服务器确认缓存是否可用。</p><p>no-store：禁用缓存。用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</p><p>public：其他用户也可使用缓存，适用于公共缓存服务器的情况。</p><p>private：只有特定用户才能使用缓存，适用于公共缓存服务器的情况。</p><p>max-age：客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</p><p>min-fresh客户机可以接收响应时间小于当前时间加上指定时间的响应。</p><p>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p><p>注意：no-cache指令并不是不缓存，no-cache的意思是可以缓存，但每次用应该去向服务器验证缓存是否可用。no-store才是不缓存内容。</p><h3 id="1-2-强缓存的过程"><a href="#1-2-强缓存的过程" class="headerlink" title="1.2 强缓存的过程"></a>1.2 强缓存的过程</h3><p>强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。</p><p>· 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header会加上Expires/Cache-Control的header；</p><p>· 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，比较Expires或Cache-Control的max-age字段值做比较, 如果在有效期内，则读取缓存内容；若缓存已过期，则重新向服务器发送请求；</p><p>· header在重新加载的时候会被更新</p><p>这里我画了两张图，浏览器第一次请求：</p><p><img src="https://user-images.githubusercontent.com/13929056/58398600-29ff1000-8088-11e9-86d8-771ff072be59.png" alt="image"></p><p>浏览器第一次请求</p><p>浏览器再次请求：</p><p><img src="https://user-images.githubusercontent.com/13929056/58398611-32efe180-8088-11e9-9f1f-809c6fceaa67.png" alt="image"></p><p>强缓存</p><p>对于强缓存，chrome浏览器的状态码：</p><p>200 OK(from disk cache)或是200 OK (from memory cache)</p><p>例如：请求某个图片后，当浏览器再次访问这个图片时，发现有这个图片的缓存，且缓存没过期，所以就使用缓存。</p><p>当浏览器发现缓存过期后，缓存并不一定不能使用了。比如文件虽然过了有效期，但内容并没有发生改变，还是可以用缓存数据。所以，这个时候需要与服务器协商，让服务器判断本地缓存是否还能使用。那么又怎么判断服务端文件有没有更新呢？主要有两种方式：</p><p>Last-Modified，If-Modified-since。</p><h3 id="二-协商缓存"><a href="#二-协商缓存" class="headerlink" title="二 协商缓存"></a>二 协商缓存</h3><p>2.1 区分Last-Modified和If-Modified-Since<br>以一个返回的接口为例：</p><p><img src="https://user-images.githubusercontent.com/13929056/58398639-43a05780-8088-11e9-8eea-8ab389d4252c.png" alt="image"></p><p>Last-Modified的格式：</p><p>Last-Modified: Mon, 17 Sep 2018 12:06:18 GMT</p><p>If-Modified-Since的格式：</p><p>If-Modified-Since: Mon, 17 Sep 2018 12:06:18 GMT</p><h3 id="2-2-Etag是什么"><a href="#2-2-Etag是什么" class="headerlink" title="2.2 Etag是什么"></a><strong>2.2 Etag是什么</strong></h3><p>web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p><h3 id="2-3-协商缓存的过程"><a href="#2-3-协商缓存的过程" class="headerlink" title="2.3 协商缓存的过程"></a><strong>2.3 协商缓存的过程</strong></h3><p>浏览器第一次请求：</p><p><img src="https://user-images.githubusercontent.com/13929056/58398670-60d52600-8088-11e9-8955-236f22e96ed0.png" alt="image"></p><p>浏览器第一次缓存</p><p>浏览器再一次请求：<br><img src="https://user-images.githubusercontent.com/13929056/58398678-67639d80-8088-11e9-9687-9ada8acca7ca.png" alt="image"></p><p>协商缓存</p><p>Last-Modified、If-Modified-Since：</p><p>· 浏览器第一次向服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified字段，表示该资源在服务器上的最后修改时间；</p><p>· 浏览器再次向服务器请求这个资源时，在request的header上加上If-Modified-Since字段，这个值就是上一次请求时返回的Last-Modified的值;</p><p>·服务器收到资源请求时，比较If-Modified-Since字段值和被请求资源的最后修改时间，若资源最后修改时间较旧，则说明文件没有修改，返回304 Not Modified, 浏览器从缓存中加载资源；若不相同，说明文件被更新，浏览器直接从服务器加载资源, 返回200；</p><p>·重新加载资源时更新Last-Modified Header</p><p>Etag、If-None-Match</p><p>· 浏览器第一次向服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag字段；</p><p>·浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match，这个值就是上一次请求时返回的ETag的值；</p><p>·服务器再次收到资源请求时，再根据资源生成一个新的ETag，与浏览器传过来If-None-Match比较，如果这两个值相同，则说明资源没有变化，返回304 Not Modified, 浏览器从缓存中加载资源，否则返回200 资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化</p><h3 id="2-4-为什么有了Last-Modified，还要用Etag呢？"><a href="#2-4-为什么有了Last-Modified，还要用Etag呢？" class="headerlink" title="2.4 为什么有了Last-Modified，还要用Etag呢？"></a><strong>2.4 为什么有了Last-Modified，还要用Etag呢？</strong></h3><p>HTTP1.1中ETag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p><p>·一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</p><p>·某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</p><p>·某些服务器不能精确的得到文件的最后修改时间。</p><p>对于上述情景，利用ETag能够更加准确的控制缓存，因为ETag是服务器自动生成的资源在服务器端的唯一标识符，资源每次变动，都会生成新的ETag值。Last-Modified与ETag是可以一起使用的，但服务器会优先验证ETag。</p><h3 id="2-5-比较强缓存和协商缓存"><a href="#2-5-比较强缓存和协商缓存" class="headerlink" title="2.5 比较强缓存和协商缓存"></a><strong>2.5 比较强缓存和协商缓存</strong></h3><p>基于上文对强缓存和协商缓存过程的解释，这里我把强缓存和协商缓存绘制在一张图里，方便比较，具体过程可以参照上文：<br><img src="https://user-images.githubusercontent.com/13929056/58398736-911cc480-8088-11e9-8ed6-5661b22fb14e.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> js </tag>
            
            <tag> 浏览器原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
