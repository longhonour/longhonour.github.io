<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WEB 前端模块化都有什么？</title>
      <link href="/2019/09/29/moudle/"/>
      <url>/2019/09/29/moudle/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16734e3a0fa304fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="总结"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到前端模块化，你第一时间能想到的是什么？Webpack？ES6 Module？还有吗？我们一起来看一下下图。 </p><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16734e324a8c8d28?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="模块化关键词"></p><p> 相信大伙儿对上图的单词都不陌生，可能用过、看过或者是只是听过。那你能不能用一张图梳理清楚上述所有词汇之间的关系呢？我们日常编写代码的时候，又和他们之间的谁谁谁有关系呢？</p><h2 id="一、千丝万缕"><a href="#一、千丝万缕" class="headerlink" title="一、千丝万缕"></a>一、千丝万缕</h2><p>为了更贴合我们的日常开发场景（前后端分离），我们尝试先从不同平台的维度区分，作为本文的切入点。</p><h3 id="1-根据平台划分"><a href="#1-根据平台划分" class="headerlink" title="1. 根据平台划分"></a>1. 根据平台划分</h3><table><thead><tr><th align="left">平台</th><th align="left">规范</th><th align="left">特性</th></tr></thead><tbody><tr><td align="left">浏览器</td><td align="left">AMD、CMD</td><td align="left">存在网络瓶颈，使用异步加载</td></tr><tr><td align="left">非浏览器</td><td align="left">CommonJS</td><td align="left">直接操作 IO，同步加载</td></tr></tbody></table><p>可以看到我们非常暴力的以是不是浏览器作为划分标准。仔细分析一下，他们之间最大的差异在于其特性上，是否存在瓶颈。 例如说网络性能瓶颈，每个模块的请求都需要发起一次网络请求，并等待资源下载完成后再进行下一步操作，那整个用户体验是非常糟糕的。 根据该场景，我们简化一下，以同步加载和异步加载两个维度进行区分。</p><table><thead><tr><th align="left">特性</th><th align="left">规范</th></tr></thead><tbody><tr><td align="left">同步加载</td><td align="left">CommonJS</td></tr><tr><td align="left">异步加载</td><td align="left">AMD、CMD</td></tr></tbody></table><h3 id="2-AMD、CMD-两大规范"><a href="#2-AMD、CMD-两大规范" class="headerlink" title="2. AMD、CMD 两大规范"></a>2. AMD、CMD 两大规范</h3><p>先忽略 CommonJS，我们先介绍下，曾经一度盛行的 AMD、CMD 两大规范。</p><table><thead><tr><th align="left">规范</th><th align="left">约束条件</th><th align="left">代表作</th></tr></thead><tbody><tr><td align="left">AMD</td><td align="left">依赖前置</td><td align="left">requirejs</td></tr><tr><td align="left">CMD</td><td align="left">就近依赖</td><td align="left">seajs</td></tr></tbody></table><p>AMD、CMD 提供了封装模块的方法，实现语法上相近，甚至于 requirejs 在后期也默默支持了 CMD 的写法。我们用一个例子，来讲清楚这两个规范之间最大的差异：依赖前置和就近依赖。</p><p><em>AMD:</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// hello.js</span><br><span class="line">define(function() &#123;</span><br><span class="line">    console.log(&apos;hello init&apos;);</span><br><span class="line">    return &#123;</span><br><span class="line">        getMessage: function() &#123;</span><br><span class="line">            return &apos;hello&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">// world.js</span><br><span class="line">define(function() &#123;</span><br><span class="line">    console.log(&apos;world init&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// main</span><br><span class="line">define([&apos;./hello.js&apos;, &apos;./world.js&apos;], function(hello) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        sayHello: function() &#123;</span><br><span class="line">            console.log(hello.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// hello init</span><br><span class="line">// world init</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><em>CMD:</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// hello.js</span><br><span class="line">define(function(require, exports) &#123;</span><br><span class="line">    console.log(&apos;hello init&apos;);</span><br><span class="line">    exports.getMessage = function() &#123;</span><br><span class="line">        return &apos;hello&apos;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// world.js</span><br><span class="line">define(function(require, exports) &#123;</span><br><span class="line">    console.log(&apos;world init&apos;);</span><br><span class="line">    exports.getMessage = function() &#123;</span><br><span class="line">        return &apos;world&apos;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// main</span><br><span class="line">define(function(require) &#123;</span><br><span class="line">    var message;</span><br><span class="line">    if (true) &#123;</span><br><span class="line">        message = require(&apos;./hello&apos;).getMessage();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        message = require(&apos;./world&apos;).getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// hello init</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><em>结论：</em> CMD 的输出结果中，没有打印”world init”。但是，<strong>需要注意的是，CMD 没有打印”world init”并是不 world.js 文件没有加载。AMD 与 CMD 都是在页面初始化时加载完成所有模块，唯一的区别就是就近依赖是当模块被 require 时才会触发执行。</strong></p><p>requirejs 和 seajs 的具体实现在这里就不展开阐述了，有兴趣的同学可以到官网了解一波，毕竟现在使用 requirejs 和 seajs 的应该很少了吧。</p><h3 id="3-CommonJS"><a href="#3-CommonJS" class="headerlink" title="3. CommonJS"></a>3. CommonJS</h3><p> 回到 CommonJS，写过 NodeJS 的同学对它肯定不会陌生。CommonJS 定义了，一个文件就是一个模块。在 node.js 的实现中，也给每个文件赋予了一个 module 对象，这个对象包括了描述当前模块的所有信息，我们尝试打印 module 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">console.log(module);</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">&#123;</span><br><span class="line">    id: &apos;/Users/x/Documents/code/demo/index.js&apos;,</span><br><span class="line">    exports: &#123;&#125;,</span><br><span class="line">    parent: &#123; module &#125;, // 调用该模块的模块，可以根据该属性查找调用链</span><br><span class="line">    filename: &apos;/Users/x/Documents/code/demo/index.js&apos;,</span><br><span class="line">    loaded: false,</span><br><span class="line">    children: [...],</span><br><span class="line">    paths: [...]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>也就是说，在 CommonJS 里面，模块是用对象来表示。我们通过“循环加载”的例子进行来加深了解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">exports.x = &apos;a1&apos;;</span><br><span class="line">console.log(&apos;a.js &apos;, require(&apos;./b.js&apos;).x);</span><br><span class="line">exports.x = &apos;a2&apos;;</span><br><span class="line"></span><br><span class="line">//b.js</span><br><span class="line">exports.x = &apos;b1&apos;;</span><br><span class="line">console.log(&apos;b.js &apos;, require(&apos;./a.js&apos;).x);</span><br><span class="line">exports.x = &apos;b2&apos;;</span><br><span class="line"></span><br><span class="line">//main</span><br><span class="line">console.log(&apos;index.js&apos;, require(&apos;./a.js&apos;).x);</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">b.js  a1</span><br><span class="line">a.js  b2</span><br><span class="line">index.js  a2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们的理论依据是模块对象，根据该依据我们进行如下分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、 a.js准备加载，在内存中生成module对象moduleA</span><br><span class="line">2、 a.js执行exports.x = &apos;a1&apos;; 在moduleA的exports属性中添加x</span><br><span class="line">3、 a.js执行console.log(&apos;a.js&apos;, require(&apos;./b.js&apos;).x); 检测到require关键字，开始加载b.js，a.js执行暂停</span><br><span class="line">4、 b.js准备加载，在内存中生成module对象moduleB</span><br><span class="line">5、 b.js执行exports.x = &apos;b1&apos;; 在moduleB的exports属性中添加x</span><br><span class="line">6、 b.js执行console.log(&apos;b.js&apos;, require(&apos;./a.js&apos;).x); 检测到require关键字，开始加载a.js，b.js执行暂停</span><br><span class="line">7、 检测到内存中存在a.js的module对象moduleA，于是可以将第6步看成console.log(&apos;b.js&apos;, moduleA.x); 在第二步中moduleA.x赋值为a1，于是输出b.js, a1</span><br><span class="line">8、 b.js继续执行，exports.x = &apos;b2&apos;，改写moduleBexports的x属性</span><br><span class="line">9、 b.js执行完成，回到a.js，此时同理可以将第3步看成console.log(&apos;a.js&apos;, modulerB.x); 输出了a.js, b2</span><br><span class="line">10、 a.js继续执行，改写exports.x = &apos;a2&apos;</span><br><span class="line">11、 输出index.js a2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>至此，“CommonJS 的模块，是一个对象。”这个概念大伙儿应该能理解吧？</p><p>回到这个例子，例子里面还出现了一个保留字 exports。其实 exports 是指向 module.exports 的一个引用。举个例子可以说明他们两个之间的关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const myFuns = &#123; a: 1 &#125;;</span><br><span class="line">let moduleExports = myFuns;</span><br><span class="line">let myExports = moduleExports;</span><br><span class="line"></span><br><span class="line">// moduleExports 重新指向</span><br><span class="line">moduleExports = &#123; b: 2 &#125;;</span><br><span class="line">console.log(myExports);</span><br><span class="line">// 输出 &#123;a : 1&#125;</span><br><span class="line"></span><br><span class="line">// 也就是说在module.exports被重新复制时，exports与它的关系就gg了。解决方法就是重新指向</span><br><span class="line">myExports = modulerExports;</span><br><span class="line">console.log(myExports);</span><br><span class="line">// 输出 &#123; b: 2 &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4-ES6-module"><a href="#4-ES6-module" class="headerlink" title="4. ES6 module"></a>4. ES6 module</h3><p>对 ES6 有所了解的同志们应该都清楚，web 前端模块化在 ES6 之前，并不是语言规范，不像是其他语言 java、php 等存在命名空间或者包的概念。上文提及的 AMD、CMD、CommonJS 规范，都是为了基于规范实现的模块化，并非 JavaScript 语法上的支持。 我们先简单的看一个 ES6 模块化写法的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">export const a = 1;</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">export const b = 2;</span><br><span class="line"></span><br><span class="line">// main</span><br><span class="line">import &#123; a &#125; from &apos;./a.js&apos;;</span><br><span class="line">import &#123; b &#125; from &apos;./b.js&apos;;</span><br><span class="line">console.log(a, b);</span><br><span class="line">//输出 1 2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>emmmm，没错，export 保留字看起来是不是和 CommonJS 的 exports 有点像？我们尝试  下从保留字对比 ES6 和 CommonJS。</p><table><thead><tr><th align="left">保留字</th><th align="left">CommonJS</th><th align="left">ES6</th></tr></thead><tbody><tr><td align="left">require</td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left">export / import</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">exports / module.exports</td><td align="left">支持</td><td align="left">不支持</td></tr></tbody></table><p>好吧，除了 require 两个都可以用之外，其他实际上还是有明显差别的。那么问题来了，既然 require 两个都可以用，那这两个在 require 使用上，有差异吗？</p><p>我们先对比下 ES6 module 和 CommonJS 之间的差异。</p><table><thead><tr><th align="left"></th><th align="left">模块输出</th><th align="left">加载方式</th></tr></thead><tbody><tr><td align="left">CommonJS</td><td align="left">值拷贝</td><td align="left">对象</td></tr><tr><td align="left">ES6</td><td align="left">引用（符号链接）</td><td align="left">静态解析</td></tr></tbody></table><p>又多了几个新颖的词汇，我们先通过例子来介绍一下值拷贝和引用的区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 值拷贝 vs 引用</span><br><span class="line"></span><br><span class="line">// CommonJS</span><br><span class="line">let a = 1;</span><br><span class="line">exports.a = a;</span><br><span class="line">exports.add = () =&gt; &#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const &#123; add, a &#125; = require(&apos;./a.js&apos;);</span><br><span class="line">add();</span><br><span class="line">console.log(a); // 1</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">export const a = 1;</span><br><span class="line">export const add = () =&gt; &#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">import &#123; a, add &#125; from &apos;./a.js&apos;;</span><br><span class="line">add();</span><br><span class="line">console.log(a); // 2</span><br><span class="line">// 显而易见CommonJS和ES6之间，值拷贝和引用的区别吧。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><em>静态解析</em>，什么是的静态解析呢？区别于 CommonJS 的模块实现，ES6 的模块并不是一个对象，而只是代码集合。也就是说，ES6 不需要和 CommonJS 一样，需要把整个文件加载进去，形成一个对象之后，才能知道自己有什么，而是在编写代码的过程中，代码是什么，它就是什么。</p><p>PS:</p><ol><li>目前各个浏览器、node.js 端对 ES6 的模块化支持实际上并不友好，更多实践同志们有兴趣可以自己搞一波。</li><li>在 ES6 中使用 require 字样，静态解析的能力将会丢失！</li></ol><h3 id="5-UMD"><a href="#5-UMD" class="headerlink" title="5. UMD"></a>5. UMD</h3><p>模块化规范中还有一个 UMD 也不得不提及一下。什么是 UMD 呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UMD = AMD + CommonJS</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>没错，UMD 就是这么简单。常用的场景就是当你封装的模块需要适配不同平台（浏览器、node.js），例如你写了一个基于 Date 对象二次封装的，对于时间的处理工具类，你想推广给负责前端页面开发的 A 同学和后台 Node.js 开发的 B 同学使用，你是不是就需要考虑你封装的模块，既能适配 Node.js 的 CommonJS 协议，也能适配前端同学使用的 AMD 协议？</p><h2 id="二、工具时代"><a href="#二、工具时代" class="headerlink" title="二、工具时代"></a>二、工具时代</h2><h3 id="1-webpack"><a href="#1-webpack" class="headerlink" title="1. webpack"></a>1. webpack</h3><p>webpack 兴起之后，什么 AMD、CMD、CommonJS、UMD，似乎都变得不重要了。因为 webpack 的模块化能力真的强。</p><p>webpack 在定义模块上，可以支持 CommonJS、AMD 和 ES6 的模块声明方式，换句话说，就是你的模块如果是使用 CommonJS、AMD 或 ES6 的语法写的，webpack 都支持！我们看下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//say-amd.js</span><br><span class="line">define(function() &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    return &#123;</span><br><span class="line">        sayHello: () =&gt; &#123;</span><br><span class="line">            console.log(&apos;say hello by AMD&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">//say-commonjs.js</span><br><span class="line">exports.sayHello = () =&gt; &#123;</span><br><span class="line">    console.log(&apos;say hello by commonjs&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">//say-es6.js</span><br><span class="line">export const sayHello = () =&gt; &#123;</span><br><span class="line">    console.log(&apos;say hello in es6&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//main</span><br><span class="line">import &#123; sayHello as sayInAMD &#125; from &apos;./say-amd&apos;;</span><br><span class="line">import &#123; sayHello as sayInCommonJS &#125; from &apos;./say-commonjs&apos;;</span><br><span class="line">import &#123; sayHello as sayInES6 &#125; from &apos;./say-es6&apos;;</span><br><span class="line"></span><br><span class="line">sayInAMD();</span><br><span class="line">sayInCommonJS();</span><br><span class="line">sayInES6();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>不仅如此，webpack 识别了你的模块之后，可以将其打包成 UMD、AMD 等等规范的模块重新输出。例如上文提及到的你需要把 Date 模块封装成 UMD 格式。只需要在 webpack 的 output 中添加 libraryTarget: ‘UMD’即可。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack打包处理IE低版本(IE8及以下)浏览器兼容问题</title>
      <link href="/2019/09/25/webpack-ie/"/>
      <url>/2019/09/25/webpack-ie/</url>
      
        <content type="html"><![CDATA[<p><a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a> 是一个前端资源加载/打包工具，现在版本已经 release 到 v2.6.1，今天的文章不直接介绍Webpack的API及使用，而是对最近项目开发中使用Webpack打包时处理IE低版本(IE8及以下)浏览器兼容问题做一次总结。</p><p>PC端项目前端基础技术选型jQuery + ES6 + EJS + Babel + Webpack：</p><ul><li>jQuery：提供选择器和ajax接口兼容支持；</li><li>ES6：跟进前端趋势，方便向后兼容；</li><li>EJS：提供前端模板引擎支持；</li><li>Babel：提供 ES6 转码支持；</li><li>Webpack: 提高前端资源加载/打包；</li></ul><p>项目开发过程都在 Chrome 浏览器中，一切都OK，没有任何问题，当在IE9以下浏览器中调试发现好多坑，现总结如下，以后新手参考。</p><h2 id="Case-One-default-、-class、catch-ES3中保留字问题"><a href="#Case-One-default-、-class、catch-ES3中保留字问题" class="headerlink" title="Case One: default 、 class、catch ES3中保留字问题"></a>Case One: <code>default</code> 、 <code>class</code>、<code>catch</code> ES3中保留字问题</h2><p>报错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT1048: 缺少标识符</span><br></pre></td></tr></table></figure><p>对应代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">e.n = function (t) &#123;</span><br><span class="line">    var n = t &amp;&amp; t.__esModule ? function () &#123;</span><br><span class="line">        return t.default</span><br><span class="line">    &#125; : function () &#123;</span><br><span class="line">        return t</span><br><span class="line">    &#125;;</span><br><span class="line">    return e.d(n, &quot;a&quot;, n), n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上查找资料，webpack有一款loader插件<a href="https://www.npmjs.com/package/es3ify-loader" target="_blank" rel="noopener">es3ify-loader</a>来处理ES3的兼容问题，修改webpack配置，问题解决，添加规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">            test: /.js$/,</span><br><span class="line">            enforce: &apos;post&apos;, // post-loader处理</span><br><span class="line">            loader: &apos;es3ify-loader&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个loader是干啥用的捏，就是把这些保留字给你加上引号，使用字符串的形式引用，请看实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 编译前</span><br><span class="line">function(t) &#123; return t.default; &#125;</span><br><span class="line"></span><br><span class="line">// 编译后</span><br><span class="line">function(t) &#123; return t[&quot;default&quot;]; &#125;</span><br></pre></td></tr></table></figure><h2 id="Case-Two-uglify-js产生问题"><a href="#Case-Two-uglify-js产生问题" class="headerlink" title="Case Two: uglify-js产生问题"></a>Case Two: uglify-js产生问题</h2><p>重新构建，在IE低版本浏览器预览，使用 <code>webpack.optimize.UglifyJsPlugin</code> 压缩时，又报上面同样的错误了，重新采用 beauty:true, build 发现引号被压缩掉了，究其原因，研究了下uglify-js默认配置，发现了 <code>compress.properties</code> 属性，增加build options如下，问题解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">    compress: &#123;</span><br><span class="line">        properties: false,</span><br><span class="line">        warnings: false</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        beautify: true</span><br><span class="line">    &#125;,</span><br><span class="line">    sourceMap: false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Case-Three-uglify-js问题"><a href="#Case-Three-uglify-js问题" class="headerlink" title="Case Three: uglify-js问题"></a>Case Three: uglify-js问题</h2><p>重新构建，在IE低版本浏览器预览，使用 <code>webpack.optimize.UglifyJsPlugin</code> 压缩时，又报上面同样的错误了，报错代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    catch: function (t) &#123;</span><br><span class="line">        return this.then(null, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续查找uglify-js配置，发现 <code>output.quote_keys</code>，修改build options，问题解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">    compress: &#123;</span><br><span class="line">        properties: false,</span><br><span class="line">        warnings: false</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        beautify: true,</span><br><span class="line">        quote_keys: true</span><br><span class="line">    &#125;,</span><br><span class="line">    sourceMap: false</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;catch&quot;: function(t) &#123;</span><br><span class="line">        return this.then(null, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Case-Four-uglify-js问题"><a href="#Case-Four-uglify-js问题" class="headerlink" title="Case Four: uglify-js问题"></a>Case Four: uglify-js问题</h2><p>重新构建，在IE低版本浏览器预览，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT3126: 无法设置未定义或 null 引用的属性</span><br></pre></td></tr></table></figure><p>继续分析压缩后代码，发现还是uglify-js问题，其mangle 配置属性 <code>mangle.screw_ie8</code> 默认为 true， 什么意思捏，意思就是把支持IE8的代码clear掉，screw you =&gt; 去你的，修改压缩配置项，重新编译，问题解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">    compress: &#123;</span><br><span class="line">        properties: false,</span><br><span class="line">        warnings: false</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        beautify: true,</span><br><span class="line">        quote_keys: true</span><br><span class="line">    &#125;,</span><br><span class="line">    mangle: &#123;</span><br><span class="line">        screw_ie8: false</span><br><span class="line">    &#125;,</span><br><span class="line">    sourceMap: false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Case-Five-ES5的API兼容报错"><a href="#Case-Five-ES5的API兼容报错" class="headerlink" title="Case Five: ES5的API兼容报错"></a>Case Five: ES5的API兼容报错</h2><p>在 webpack 的 entry 入口文件top引入 <code>es5-shim</code> 问题解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;es5-shim&apos;);</span><br><span class="line">require(&apos;es5-shim/es5-sham&apos;);</span><br></pre></td></tr></table></figure><h2 id="Case-Six-Console-log-问题"><a href="#Case-Six-Console-log-问题" class="headerlink" title="Case Six: Console.log 问题"></a>Case Six: Console.log 问题</h2><p>在 webpack 的 entry 入口文件top引入 <code>console-polyfill</code> 问题解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;console-polyfill&apos;);</span><br></pre></td></tr></table></figure><h2 id="Case-Seven-Promise-兼容"><a href="#Case-Seven-Promise-兼容" class="headerlink" title="Case Seven: Promise 兼容"></a>Case Seven: Promise 兼容</h2><p>在 webpack 的 entry 入口文件top引入 <code>es6-promise</code> 问题解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;es6-promise&apos;);</span><br></pre></td></tr></table></figure><h2 id="Case-Eight-Object-defineProperty-问题"><a href="#Case-Eight-Object-defineProperty-问题" class="headerlink" title="Case Eight: Object.defineProperty 问题"></a>Case Eight: Object.defineProperty 问题</h2><p>这个case 应该说是最难搞的一个case了，耗时也比较长，关键点在于使用 <code>es5-shim</code>/<code>es5-sham</code>也有问题，查看你官网发现在低版本浏览器也会有问题，官网描述如下：</p><blockquote><p>⚠️ Object.defineProperty<br>In the worst of circumstances, IE 8 provides a version of this method that only works on DOM objects. This sham will not be installed. The given version of defineProperty will throw an exception if used on non-DOM objects.<br>In slightly better circumstances, this method will silently fail to set “writable”, “enumerable”, and “configurable” properties.<br>Providing a getter or setter with “get” or “set” on a descriptor will silently fail on engines that lack “defineGetter” and “defineSetter”, which include all versions of IE.<br><a href="https://github.com/es-shims/es5-shim/issues#issue/5" target="_blank" rel="noopener">https://github.com/es-shims/es5-shim/issues#issue/5</a></p></blockquote><p>那这个Object.defineProperty 是如何产生的呢，这个是babel编译后产生的，当我们在代码使用 <code>import``export</code> ES6 Module时出现的，那你可能最直接的想法就是我不用ES6 Module了，改用Commonjs规范，OK，修改后编译，确实解决了问题，但是查看代码里还是有一段代码的，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">e.d = function(t, n, r) &#123;</span><br><span class="line">    e.o(t, n) || Object.defineProperty(t, n, &#123;</span><br><span class="line">        &quot;configurable&quot;: !1,</span><br><span class="line">        &quot;enumerable&quot;: !0,</span><br><span class="line">        &quot;get&quot;: r</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, e.n = function(t) &#123;</span><br><span class="line">    var n = t &amp;&amp; t.__esModule ? function() &#123;</span><br><span class="line">        return t[&quot;default&quot;];</span><br><span class="line">    &#125; : function() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;;</span><br><span class="line">    return e.d(n, &quot;a&quot;, n), n;</span><br><span class="line">&#125;, e.o = function(t, e) &#123;</span><br><span class="line">    return Object.prototype.hasOwnProperty.call(t, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码已经做了容错判断。</p><h2 id="Case-Nine-Object-defineProperty-问题"><a href="#Case-Nine-Object-defineProperty-问题" class="headerlink" title="Case Nine: Object.defineProperty 问题"></a>Case Nine: Object.defineProperty 问题</h2><p>重新构建，加入 <code>json3</code> 处理 JSON 对象兼容时，代码在此处抛出了异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var hasGetter = &apos;get&apos; in descriptor;</span><br><span class="line">var hasSetter = &apos;set&apos; in descriptor;</span><br><span class="line">if (!supportsAccessors &amp;&amp; (hasGetter || hasSetter)) &#123;</span><br><span class="line">    throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析supportsAccessors代码逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var supportsAccessors = owns(prototypeOfObject, &apos;__defineGetter__&apos;);</span><br></pre></td></tr></table></figure><p>通过断点调试，supportsAccessors值为false且hasGetter或者hasSetter时抛出了异常，也就是说当前js引擎不支持访问器属性，却在属性描述符中设置了get，set,那么就会抛出异常。查看 <a href="https://github.com/zuojj/fedlab/issues/“defineGetter”的兼容情况是只兼容IE11" target="_blank" rel="noopener">defineGetter</a> 的兼容情况，只兼容IE11，虽然IE9、IE10同样不支持defineGetter,不过他们直接支持Object.defineProperty方法和get语法，无需sham，所以代码并不会走到异常这里。但是IE8以下就扯淡了。解决这种情况只能修改源代码了。</p><p>至此，Webpack打包时，IE低版本浏览器(IE8及以下)遇到的兼容问题就总结这里，如果你有新的问题，欢迎留言。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决ie低版本浏览器兼容rgba属性</title>
      <link href="/2019/09/25/ie-rgba/"/>
      <url>/2019/09/25/ie-rgba/</url>
      
        <content type="html"><![CDATA[<p>在使用rgba设置元素颜色属性时，ie低版本存在兼容性问题。</p><p>html代码如下<br><code>&lt;div class=&quot;test&quot;&gt;&lt;img src=&quot;img/1.png&quot;&gt;&lt;i&gt;覆盖文字&lt;/i&gt;&lt;/div&gt;</code></p><p>CSS代码如下<br><img src="https://user-images.githubusercontent.com/13929056/58398942-17d1a180-8089-11e9-92e2-85396132f6b2.png" alt="image"><br>IE10，IE8,IE7均显示正常，<br><img src="https://user-images.githubusercontent.com/13929056/58398954-24ee9080-8089-11e9-9b53-94fdbdb1055e.png" alt="image"><br><img src="https://user-images.githubusercontent.com/13929056/58398959-2750ea80-8089-11e9-862c-0d45619800e9.png" alt="image"><br>但在IE9下却出现问题：<br><img src="https://user-images.githubusercontent.com/13929056/58398975-2d46cb80-8089-11e9-823a-5cbcca93d36d.png" alt="image"><br>问题所在：<br>ie9下会重复应用filter和rgba导致透明度失效<br><strong>解决方法：</strong><br>方法1：<br>取消ie9下的滤镜css：</p><p><strong>:root .test i{filter:none;}</strong> </p><p>取消ie9下的滤镜css：</p><p>:root .test i{filter:none;} </p><p>这里用到了CSS3 :root 选择器：所有主流浏览器均支持 :root 选择器，除了 IE8 及更早的版本，而滤镜filter只有ie9以及更低的ie版本才支持，ie10开始已废弃不支持filter，这样刚好可利用:root来实现针对ie9的hack!!<br>装了ie10或更高版本的ie，可用ietester新建ie9模式标签查看上面代码运行效果。<br>(注意：装了ie10或更高版本的ie，即使将文档模式调成ie9，会发现上面 的代码也显示正确，合理的解释是：ie10开始已废弃不支持filter，即使文档模式调成ie9，filter也不会生效！另外提一下 css \9 写法是针对ie所有版本的hack写法，网上说的只是针对ie6~8的hack说法是错误的！)<br>全兼容完整代码如下：<br><code>.test i{         background:rgba(0,0,0,.8);         filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#b2000000, endColorstr=#b2000000);}:root .test i{filter:none;}</code></p><p>输入十六进制的颜色值以及透明度，自动在IE的过渡滤镜以及CSS3中的rgba属性之间进行十六进制与十进制的换算。在线转换工具<br><a href="http://linxz.github.io/tianyizone/hex_color.html" target="_blank" rel="noopener">http://linxz.github.io/tianyizone/hex_color.html</a><br>`</p><h2 id="输入十六进制的颜色值以及透明度，自动在IE的过渡滤镜以及CSS3中的rgba属性之间进行十六进制与十进制的换算。在线转换工具http-linxz-github-io-tianyizone-hex-color-html"><a href="#输入十六进制的颜色值以及透明度，自动在IE的过渡滤镜以及CSS3中的rgba属性之间进行十六进制与十进制的换算。在线转换工具http-linxz-github-io-tianyizone-hex-color-html" class="headerlink" title="输入十六进制的颜色值以及透明度，自动在IE的过渡滤镜以及CSS3中的rgba属性之间进行十六进制与十进制的换算。在线转换工具http://linxz.github.io/tianyizone/hex_color.html"></a>输入十六进制的颜色值以及透明度，自动在IE的过渡滤镜以及CSS3中的rgba属性之间进行十六进制与十进制的换算。在线转换工具<a href="http://linxz.github.io/tianyizone/hex_color.html" target="_blank" rel="noopener">http://linxz.github.io/tianyizone/hex_color.html</a></h2><p>`</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解浏览器缓存，教你提高用户体验</title>
      <link href="/2019/09/25/brower-cache/"/>
      <url>/2019/09/25/brower-cache/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-区分Expires和Cache-Control"><a href="#1-1-区分Expires和Cache-Control" class="headerlink" title="1.1 区分Expires和Cache-Control"></a>1.1 区分Expires和Cache-Control</h3><p>以一个接口返回的响应头为例：<br><img src="https://user-images.githubusercontent.com/13929056/58398559-02a84300-8088-11e9-9b00-45fed12a8353.png" alt="image"><br>这里我画了张思维导图，对Expires和Cache-Control做比较：<br><img src="https://user-images.githubusercontent.com/13929056/58398566-089e2400-8088-11e9-9308-6252caff9978.png" alt="image"><br>具体介绍Expires和Cache-Control：</p><p>Expires:</p><p>(1)Expires是HTTP1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略；</p><p>(2)Expires规定了缓存失效时间（Date为当前时间），是绝对时间。由于Expires返回的是一个绝对时间，在服务器时间与客户端时间相差较大的时候，缓存命中不准确；</p><p>Cache-Control：</p><p>(1)Cache-Control是HTTP1.1的</p><p>(2)Cache-Control的max-age规定了缓存有效时间（2552s)，是相对时间；</p><p>(3)若响应头Expires和Cache-Control同时存在，Cache-Control优先级高于Expires</p><p>Cache-Control的常用指令：</p><p>no-cache：不使用本地缓存，需要使用协商缓存，也就是先与服务器确认缓存是否可用。</p><p>no-store：禁用缓存。用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</p><p>public：其他用户也可使用缓存，适用于公共缓存服务器的情况。</p><p>private：只有特定用户才能使用缓存，适用于公共缓存服务器的情况。</p><p>max-age：客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</p><p>min-fresh客户机可以接收响应时间小于当前时间加上指定时间的响应。</p><p>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p><p>注意：no-cache指令并不是不缓存，no-cache的意思是可以缓存，但每次用应该去向服务器验证缓存是否可用。no-store才是不缓存内容。</p><h3 id="1-2-强缓存的过程"><a href="#1-2-强缓存的过程" class="headerlink" title="1.2 强缓存的过程"></a>1.2 强缓存的过程</h3><p>强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。</p><p>· 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header会加上Expires/Cache-Control的header；</p><p>· 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，比较Expires或Cache-Control的max-age字段值做比较, 如果在有效期内，则读取缓存内容；若缓存已过期，则重新向服务器发送请求；</p><p>· header在重新加载的时候会被更新</p><p>这里我画了两张图，浏览器第一次请求：</p><p><img src="https://user-images.githubusercontent.com/13929056/58398600-29ff1000-8088-11e9-86d8-771ff072be59.png" alt="image"></p><p>浏览器第一次请求</p><p>浏览器再次请求：</p><p><img src="https://user-images.githubusercontent.com/13929056/58398611-32efe180-8088-11e9-9f1f-809c6fceaa67.png" alt="image"></p><p>强缓存</p><p>对于强缓存，chrome浏览器的状态码：</p><p>200 OK(from disk cache)或是200 OK (from memory cache)</p><p>例如：请求某个图片后，当浏览器再次访问这个图片时，发现有这个图片的缓存，且缓存没过期，所以就使用缓存。</p><p>当浏览器发现缓存过期后，缓存并不一定不能使用了。比如文件虽然过了有效期，但内容并没有发生改变，还是可以用缓存数据。所以，这个时候需要与服务器协商，让服务器判断本地缓存是否还能使用。那么又怎么判断服务端文件有没有更新呢？主要有两种方式：</p><p>Last-Modified，If-Modified-since。</p><h3 id="二-协商缓存"><a href="#二-协商缓存" class="headerlink" title="二 协商缓存"></a>二 协商缓存</h3><p>2.1 区分Last-Modified和If-Modified-Since<br>以一个返回的接口为例：</p><p><img src="https://user-images.githubusercontent.com/13929056/58398639-43a05780-8088-11e9-8eea-8ab389d4252c.png" alt="image"></p><p>Last-Modified的格式：</p><p>Last-Modified: Mon, 17 Sep 2018 12:06:18 GMT</p><p>If-Modified-Since的格式：</p><p>If-Modified-Since: Mon, 17 Sep 2018 12:06:18 GMT</p><h3 id="2-2-Etag是什么"><a href="#2-2-Etag是什么" class="headerlink" title="2.2 Etag是什么"></a><strong>2.2 Etag是什么</strong></h3><p>web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p><h3 id="2-3-协商缓存的过程"><a href="#2-3-协商缓存的过程" class="headerlink" title="2.3 协商缓存的过程"></a><strong>2.3 协商缓存的过程</strong></h3><p>浏览器第一次请求：</p><p><img src="https://user-images.githubusercontent.com/13929056/58398670-60d52600-8088-11e9-8955-236f22e96ed0.png" alt="image"></p><p>浏览器第一次缓存</p><p>浏览器再一次请求：<br><img src="https://user-images.githubusercontent.com/13929056/58398678-67639d80-8088-11e9-9687-9ada8acca7ca.png" alt="image"></p><p>协商缓存</p><p>Last-Modified、If-Modified-Since：</p><p>· 浏览器第一次向服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified字段，表示该资源在服务器上的最后修改时间；</p><p>· 浏览器再次向服务器请求这个资源时，在request的header上加上If-Modified-Since字段，这个值就是上一次请求时返回的Last-Modified的值;</p><p>·服务器收到资源请求时，比较If-Modified-Since字段值和被请求资源的最后修改时间，若资源最后修改时间较旧，则说明文件没有修改，返回304 Not Modified, 浏览器从缓存中加载资源；若不相同，说明文件被更新，浏览器直接从服务器加载资源, 返回200；</p><p>·重新加载资源时更新Last-Modified Header</p><p>Etag、If-None-Match</p><p>· 浏览器第一次向服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag字段；</p><p>·浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match，这个值就是上一次请求时返回的ETag的值；</p><p>·服务器再次收到资源请求时，再根据资源生成一个新的ETag，与浏览器传过来If-None-Match比较，如果这两个值相同，则说明资源没有变化，返回304 Not Modified, 浏览器从缓存中加载资源，否则返回200 资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化</p><h3 id="2-4-为什么有了Last-Modified，还要用Etag呢？"><a href="#2-4-为什么有了Last-Modified，还要用Etag呢？" class="headerlink" title="2.4 为什么有了Last-Modified，还要用Etag呢？"></a><strong>2.4 为什么有了Last-Modified，还要用Etag呢？</strong></h3><p>HTTP1.1中ETag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p><p>·一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</p><p>·某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</p><p>·某些服务器不能精确的得到文件的最后修改时间。</p><p>对于上述情景，利用ETag能够更加准确的控制缓存，因为ETag是服务器自动生成的资源在服务器端的唯一标识符，资源每次变动，都会生成新的ETag值。Last-Modified与ETag是可以一起使用的，但服务器会优先验证ETag。</p><h3 id="2-5-比较强缓存和协商缓存"><a href="#2-5-比较强缓存和协商缓存" class="headerlink" title="2.5 比较强缓存和协商缓存"></a><strong>2.5 比较强缓存和协商缓存</strong></h3><p>基于上文对强缓存和协商缓存过程的解释，这里我把强缓存和协商缓存绘制在一张图里，方便比较，具体过程可以参照上文：<br><img src="https://user-images.githubusercontent.com/13929056/58398736-911cc480-8088-11e9-8ed6-5661b22fb14e.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> css </tag>
            
            <tag> 浏览器原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
